#!/usr/bin/env python3
#-------------------------------------------------------------------------------
# scripts/stub2hdr.py
#
# Extracts a header file from a stubbed ELF (object/archive/shared object) file
# The stubbed ELF file must contain no implementations i.e:
#   - only uninitialized variables 
#   - empty function bodies
#
# Will Denissen
# This code is in the public domain
#-------------------------------------------------------------------------------
import argparse
import sys, os

# For running from development directory. It should take precedence over the
# installed pyelftools.
dev_dir = os.path.dirname(sys.argv[0]) + '/..'
sys.path.insert(0, dev_dir)

from elftools import __version__
from elftools.elf.elffile import ELFFile
from elftools.common.utils import bytes2str

PROG = 'extract_stub.py'

class DumpSource:
    def __init__(self, ifile, ofile, args):
        ''' dump header from the .debug_info section.
            ifile:
                input stream to read from

            ofile:
                output stream to write to
        '''
        self.ifile   = ifile
        self.ofile   = ofile
        self.args    = args
        self.ind_lvl = 0
        self.elffile = ELFFile(self.ifile)
        self.dynsym  = self.elffile.get_section_by_name('.dynsym')

    def dump_source(self):
        ''' dump source file from the shared library.
        '''
        self.pr('// generated by  : %s' % PROG)
        self.pr('\n// generated from: %s' % self.args.ifnam)

        self.pr('\n// number of symbols: %s' % self.dynsym.num_symbols())
        for sym in self.dynsym.iter_symbols():
            info = sym['st_info']
            self.pr_ln('%-10s %-10s %s' % (info['bind'], info['type'], sym.name))

        self.pr('\n// end of source\n')
 
    def pr_ln(self, txt):
        '''returns txt on a new line with the current indentation'''
        self.pr('\n%*s%s' % (2*self.ind_lvl, '', txt))

    def pr(self, txt):
        '''writes txt to output file'''
        self.ofile.write(txt)

SCRIPT_DESCRIPTION = 'Extract stub file from a ELF shared object'
VERSION_STRING = '%%(prog)s: based on pyelftools %s' % __version__

def main(stream=None):
    argparser = argparse.ArgumentParser(
            # usage='%(prog)s [options] <elf+dwarf-stubfile>',
            description = SCRIPT_DESCRIPTION,
            prog        = PROG)
    argparser.add_argument('-v', '--version',
            action      = 'version', 
            version     = VERSION_STRING)
    argparser.add_argument('-V', '--verbosity',
            default     = '',
            dest        = 'verbosity',
            help        = 'verbosity of output: one of t)ype f)ull')
    argparser.add_argument('-o', 
            dest        = 'odir',
            help        = 'output directory')
    argparser.add_argument( 
            dest  = 'idir',
            help = 'input directory')
    args = argparser.parse_args()

    if not args.idir:
        argparser.print_help()
        return

    if not args.odir:
        args.odir = args.idir[:-3]+'out'

    print('... Reading from: %s ...' % args.idir)
    print('... Writing   to: %s ...' % args.odir)

    for ifnam in os.listdir(args.idir):
        if not ifnam.endswith('.so'): continue
        args.ifnam = ifnam
        ofnam = '%s.c' % ifnam[3:-3]
        print('... Processing file: <idir>/%s --> <odir>%s ...' % (ifnam, ofnam))
        ipath = args.idir +'/'+ifnam
        opath = args.odir +'/'+ofnam

        ofile = open(opath, 'w')
        with open(ipath, 'rb') as ifile:
            dumper = DumpSource(ifile, ofile, args)
            dumper.dump_source()

#-------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
    #profile_main()
